export const defaultIgnoreList = [
  // Version control
  '.git/**',
  '.hg/**',
  '.hgignore',
  '.svn/**',

  // Dependency directories
  '**/node_modules/**',
  '**/bower_components/**',
  '**/jspm_packages/**',
  'vendor/**',
  '**/.bundle/**',
  '**/.gradle/**',
  'target/**',

  // Logs
  'logs/**',
  '**/*.log',
  '**/npm-debug.log*',
  '**/yarn-debug.log*',
  '**/yarn-error.log*',

  // Runtime data
  'pids/**',
  '*.pid',
  '*.seed',
  '*.pid.lock',

  // Directory for instrumented libs generated by jscoverage/JSCover
  'lib-cov/**',

  // Coverage directory used by tools like istanbul
  'coverage/**',

  // nyc test coverage
  '.nyc_output/**',

  // Grunt intermediate storage
  '.grunt/**',

  // node-waf configuration
  '.lock-wscript',

  // Compiled binary addons
  'build/Release/**',

  // TypeScript v1 declaration files
  'typings/**',

  // Optional npm cache directory
  '**/.npm/**',

  // Cache directories
  '.eslintcache',
  '.rollup.cache/**',
  '.webpack.cache/**',
  '.parcel-cache/**',
  '.sass-cache/**',
  '*.cache',

  // Optional REPL history
  '.node_repl_history',

  // Output of 'npm pack'
  '*.tgz',

  // Yarn files
  '**/.yarn/**',

  // Yarn Integrity file
  '**/.yarn-integrity',

  // dotenv environment variables file
  '.env',

  // next.js build output
  '.next/**',

  // nuxt.js build output
  '.nuxt/**',

  // vuepress build output
  '.vuepress/dist/**',

  // Serverless directories
  '.serverless/**',

  // FuseBox cache
  '.fusebox/**',

  // DynamoDB Local files
  '.dynamodb/**',

  // TypeScript output
  'dist/**',

  // OS generated files
  '**/.DS_Store',
  '**/Thumbs.db',

  // Editor directories and files
  '.idea/**',
  '.vscode/**',
  '**/*.swp',
  '**/*.swo',
  '**/*.swn',
  '**/*.bak',

  // Build outputs
  'build/**',
  'out/**',

  // Temporary files
  'tmp/**',
  'temp/**',

  // repomix output
  '**/repomix-output.*',
  '**/repopack-output.*', // Legacy

  // Essential Node.js-related entries
  '**/package-lock.json',
  '**/yarn-error.log',
  '**/yarn.lock',
  '**/pnpm-lock.yaml',
  '**/bun.lockb',
  '**/bun.lock',

  // Essential Python-related entries
  '**/__pycache__/**',
  '**/*.py[cod]',
  '**/venv/**',
  '**/.venv/**',
  '**/.pytest_cache/**',
  '**/.mypy_cache/**',
  '**/.ipynb_checkpoints/**',
  '**/Pipfile.lock',
  '**/poetry.lock',
  '**/uv.lock',

  // Essential Rust-related entries
  '**/Cargo.lock',
  '**/Cargo.toml.orig',
  '**/target/**',
  '**/*.rs.bk',

  // Essential PHP-related entries
  '**/composer.lock',

  // Essential Ruby-related entries
  '**/Gemfile.lock',

  // Essential Go-related entries
  '**/go.sum',

  // Essential Elixir-related entries
  '**/mix.lock',

  // Essential Haskell-related entries
  '**/stack.yaml.lock',
  '**/cabal.project.freeze',
];

/**
 * Simple glob pattern matcher that supports:
 * - * (matches any characters within a single path segment)
 * - ** (matches any path segments)
 * - Exact matches
 */
export function matchesPattern(filePath: string, pattern: string, _depth: number = 0): boolean {
  // Prevent infinite recursion
  if (_depth > 10) return false;
  
  // Normalize paths (remove leading ./ and use forward slashes)
  const normalizedPath = filePath.replace(/^\.\//, '').replace(/\\/g, '/');
  let normalizedPattern = pattern.replace(/^\.\//, '').replace(/\\/g, '/');
  
  // Handle patterns starting with **/
  if (normalizedPattern.startsWith('**/')) {
    const subPattern = normalizedPattern.slice(3); // Remove **/
    // Try matching at current level and all subdirectories
    const pathParts = normalizedPath.split('/');
    
    // Check if pattern matches at any level
    for (let i = 0; i < pathParts.length; i++) {
      const subPath = pathParts.slice(i).join('/');
      if (matchesPattern(subPath, subPattern, _depth + 1)) {
        return true;
      }
    }
    // Also check the full path
    return matchesPattern(normalizedPath, subPattern, _depth + 1);
  }
  
  // Handle directory patterns ending with /** (should match the directory itself and its contents)
  if (normalizedPattern.endsWith('/**')) {
    const directoryPattern = normalizedPattern.slice(0, -3); // Remove /**
    // Match the directory itself or anything inside it
    return matchesPattern(normalizedPath, directoryPattern, _depth + 1) ||
           normalizedPath.startsWith(directoryPattern + '/');
  }
  
  // Convert glob pattern to regex
  let regexPattern = normalizedPattern
    .replace(/\*\*/g, '§DOUBLESTAR§') // Temporarily replace ** to avoid conflict with *
    .replace(/\*/g, '[^/]*')          // * matches anything except path separators
    .replace(/§DOUBLESTAR§/g, '.*')   // ** matches everything including path separators
    .replace(/\./g, '\\.')            // Escape dots
    .replace(/\?/g, '.');             // ? matches single character
  
  // Add anchors
  regexPattern = `^${regexPattern}$`;
  
  const regex = new RegExp(regexPattern);
  return regex.test(normalizedPath);
}

/**
 * Check if a file or directory should be ignored based on the ignore patterns
 */
export function shouldIgnore(filePath: string, ignorePatterns: string[] = defaultIgnoreList): boolean {
  const normalizedPath = filePath.replace(/^\.\//, '').replace(/\\/g, '/');
  
  for (const pattern of ignorePatterns) {
    if (matchesPattern(normalizedPath, pattern)) {
      return true;
    }
  }
  
  return false;
}